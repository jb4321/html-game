<!DOCTYPE html>
<style>
    body {
        background-color:rgb(126, 126, 126);
        font-family:'Courier New', Courier, monospace;
        
        line-height: 1;
    }
    
    header {
        font-weight: bold;
        font-size: 45px;
    }
    .main {
        display: flex;
        flex-flow: row wrap;
        justify-content: space-between;
    }
    .game {
        font-size: 0.8cm;
        border: 3px black solid;
        overflow: hidden;
        background-color: black;
    }
    .unselectable {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    .column {
        background-color: lightgray;
        font-size: 20px;
        border: 3px black solid;
        flex-basis: 15%;   
    }
    .column_element{
        border-bottom:black solid 3px;
        padding: 10px;
    }
    .buttons {
        font-family:'Courier New', Courier, monospace;
        font-size: 20px;
        font-weight: bold;
    }
    .other_column {
        background-color: lightgray;
        flex-basis: 20%;
        border: 3px black solid;
    }
    .selected_item{
        color:lime
    }

</style>
<html>
    <head>
        <meta charset="UTF-8">
        <title class="selected"> One File </title>
        <link rel="icon" href = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGRSURBVDhPjZM9LENRGIbv9bfaDbogQSIkUptBdJBIxMDCpkRCm0gMFpvBwKJNNNTGYjCRSspiI5EwiARTEztzyfW8PedcbtXPmzz9vnO+n957z3d8r0rBgdeFmYcxaNUeKsE9LPlTFRsqbEBhI2YTUpWNn7UFyzQqa1GnH4qbMKegYgW2oZ8kX8iHnI2loWBrzBOwyGIW4BlGKbrRfrXI68WcQAtkyUv5bHazuIV3GFAxex34azAO0hGsEnuwTS6hHnr0Ckm72LHF7fhXMAENlkntEWuzT7cLqkmqQQKkfWvXodm4EWlPMcnlJtQgZnzvztpha2vJxVxuTA0C438e6T/kcgM10JBIGiDpzNpacjGXW1KDovG9aWtX4NW4Eb2AYpLLLaqBvqiOcE5HxFd+xI/DIbyBhkd+nNgTOX34s6CavBukDGYR/hokFR+DBilDXto10FgWYAj0j3uQJ+Eaq7hGWfMyA5qLcxghXg6/PEm6TBugWf9Nkcv07eho1InRdR4Eja2kV7qAHIVfrrPnfQDq2nHJefonxAAAAABJRU5ErkJggg==">
    </head>

    <body>
        <header style="text-align: center;"> 1File  </header> <br>
        
        <div class="main">
            <div class="column">
                <div class="column_element">
                    <b>Health: <hp id = "health"  style="color:red">100/100</b></hp>
                    <b>Hunger: <hp id = "hunger"  style="color:yellow">100/100</b></hp><br>
                    <b> Pos : <pos id = "pos"><pos> </b>
                </div>
                <div class="column_element" id = "inventory"  > </div>
            </div>
            

            <div id="game" class="game">
                
                <p style="color: burlywood;">▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢<br>◎◉◍▢▣▤▥◰▦▧▨▢▩◧◨◩◪◫◖◈▢◸◻◼◡▢<br>▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢</p>
            </div>
            <div class="column" >
                <div class ="column_element" id="crafting" ></div>
            </div>
        </div>
        <button class="buttons" onclick="day = !day;renderGame()">Night</button>
    </body>
</html>

<script>
//CLASSES

//Noise
function Grad(x, y) {
    this.x = x; this.y = y;
}
Grad.prototype.dot2 = function(x, y) {
    return this.x*x + this.y*y;
}; 
class Noise{
    /*
    * A speed-improved perlin and simplex noise algorithms for 2D.
    *
    * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
    * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
    * Better rank ordering method by Stefan Gustavson in 2012.
    * Converted to Javascript by Joseph Gentle.
    *
    * Version 2012-03-09
    *
    * This code was placed in the public domain by its original author,
    * Stefan Gustavson. You may use it as you see fit, but
    * attribution is appreciated.
    *
    * 2022-04-04
    * Added octaves and some modifications by jb431
    */
    constructor(c_seed = 0)
    {
        this.seed_noise(c_seed)
    }
    // Skewing and unskewing factors for 2, 3, and 4 dimensions
    F2 = 0.5*(Math.sqrt(3)-1)
    G2 = (3-Math.sqrt(3))/6

    grad3 = [new Grad(1,1),new Grad(-1,1),new Grad(1,-1),new Grad(-1,-1)]
    p = [151,160,137,91,90,15,
    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

    // To remove the need for index wrapping, double the permutation table length
    perm = new Array(512);
    gradP = new Array(512);

    seed_noise(seed){
        if(seed > 0 && seed < 1) {
            // Scale the seed out
            seed *= 65536;
        }      
        seed = Math.floor(seed);
            if(seed < 256) {
            seed |= seed << 8;
        }
    
        for(var i = 0; i < 256; i++) {
            var v;
            if (i & 1) {
                v = this.p[i] ^ (seed & 255);
            } else {
                v = this.p[i] ^ ((seed>>8) & 255);
            }

            this.perm[i] = this.perm[i + 256] = v;
            this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 4];
        } 
    }
    // 2D Simplex Noise
    simplex2(xin,yin) {
        var n0, n1, n2; // Noise contributions from the three corners
        // Skew the input space to determine which simplex cell we're in
        var s = (xin+yin)*this.F2; // Hairy factor for 2D
        var i = Math.floor(xin+s);
        var j = Math.floor(yin+s);
        var t = (i+j)*this.G2;
        var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
        var y0 = yin-j+t;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
            i1=1; j1=0;
        } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
            i1=0; j1=1;
        }
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        var x1 = x0 - i1 + this.G2; // Offsets for middle corner in (x,y) unskewed coords
        var y1 = y0 - j1 + this.G2;
        var x2 = x0 - 1 + 2 * this.G2; // Offsets for last corner in (x,y) unskewed coords
        var y2 = y0 - 1 + 2 * this.G2;

        // Work out the hashed gradient indices of the three simplex corners
        i &= 255;
        j &= 255;
        var gi0 = this.gradP[i+this.perm[j]];
        var gi1 = this.gradP[i+i1+this.perm[j+j1]];
        var gi2 = this.gradP[i+1+this.perm[j+1]];
        // Calculate the contribution from the three corners
        var t0 = 0.5 - x0*x0-y0*y0;
        if(t0<0) {
            n0 = 0;
        } else {
            t0 *= t0;
            n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
        }
        var t1 = 0.5 - x1*x1-y1*y1;
        if(t1<0) {
            n1 = 0;
        } else {
            t1 *= t1;
            n1 = t1 * t1 * gi1.dot2(x1, y1);
        }
        var t2 = 0.5 - x2*x2-y2*y2;
        if(t2<0) {
            n2 = 0;
        } else {
            t2 *= t2;
            n2 = t2 * t2 * gi2.dot2(x2, y2);
        }
        
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].

        return 70 * (n0 + n1 + n2);
    }
    // ##### Perlin noise functions
    fade(t) {
        return t*t*t*(t*(t*6-15)+10);
    }
    lerp(a, b, t) {
        return (1-t)*a + t*b;
    }
    // 2D Perlin Noise
    perlin2(x, y) {
        // Find unit grid cell containing point
        var X = Math.floor(x), Y = Math.floor(y);
        // Get relative xy coordinates of point within that cell
        x = x - X; y = y - Y;
        // Wrap the integer cells at 255 (smaller integer period can be introduced here)
        X = X & 255; Y = Y & 255;

        // Calculate noise contributions from each of the four corners
        var n00 = this.gradP[X+this.perm[Y]].dot2(x, y);
        var n01 = this.gradP[X+this.perm[Y+1]].dot2(x, y-1);
        var n10 = this.gradP[X+1+this.perm[Y]].dot2(x-1, y);
        var n11 = this.gradP[X+1+this.perm[Y+1]].dot2(x-1, y-1);

        // Compute the fade curve value for x
        var u = this.fade(x);

        // Interpolate the four results
        return this.lerp(
            this.lerp(n00, n10, u),
            this.lerp(n01, n11, u),
            this.fade(y));
    };
    // 2D octaves perlin or simplex
    octave2(x,y,num_iterations,persistence,scale,is_simplex = false){
        let max_amp = 0
        let amp = 1
        let freq = 1
        let noise_value = 0
        for(let i = 0; i < num_iterations; i++){
            if (is_simplex){
                noise_value += this.simplex2(x * freq, y * freq) * amp
            }
            else{
                noise_value += this.perlin2(x * freq, y * freq) * amp
            }
            
            max_amp += amp
            amp *= persistence
            freq *= 2
        }
        noise_value /= max_amp

        return noise_value
    }
}

//Game 
class Vector{
    constructor(x = 0,y = 0){
        this.x = x
        this.y = y
    }
    checkBound() {
        return this.x < 0 || this.x >= size || this.y < 0 || this.y >= size 
    }
    to_string() {
        return `${this.x},${this.y}`
    }
}
class SquareCell {
    constructor(ground_name = "none", game_object_name = "none") {
        this.ground = {
            name : ground_name,
            get info(){
                return ground_info[this.name]
            }
        }
        

        this.game_object = {
            name : game_object_name,
            get info(){
                return game_object_info[this.name]
            }
        }
    }
    getRenderInfo(){
        if(this.isEmpty()){
            return new RenderInfo(this.ground.info,this.ground.info)
        }
        else {
            return new RenderInfo(this.ground.info,this.game_object.info.color,this.game_object.info.sign)
        }
    }
    isBlocking(){
        return this.ground.name == "water" || this.game_object.info.blocking
    }
    isEmpty(){
        return this.game_object.name == "none"
    }
}
class RenderInfo {
    constructor(background_color = "white",color = "black",sign = "◼") {
        this.background_color = background_color
        this.color = color
        this.sign = sign
    }
}
class Player{
    constructor(pos){
        this.pos = pos
        this.inventory = {}
        this.selected_item = ""

        this.max_health = 100
        this.max_hunger = 100

        this.health = 100
        this.hunger = 100
    }
    kill(){
        this.inventory = {}
        this.health = 100
        this.hunger = 100
        teleport(new Vector())
    }
    update(){
        if (this.hunger > 0){
            this.hunger -= 0
        }
        else{
            this.health -= 1
            if(this.health <= 0){
                this.kill()
            } 
        }
        
        
    }
    addItem(item_name,count = 1){
        if(item_name in this.inventory){
            this.inventory[item_name] += count}
        else{
            this.inventory[item_name] = count}
    }
    removeItem(item_name,count = 1){
        this.inventory[item_name] -= count
        if (this.inventory[item_name] <= 0){
            delete this.inventory[item_name]
        }
    }
    feed(item){
        if(this.hunger < this.max_hunger){
            this.hunger += item_info[item].food
            this.removeItem(item)
            renderStats()
        }
    }
}


//CONSTANT DECLARATIONS
const world_border_camera_effect = false
const biomes = {
    water : [0.40],
    shallow_water : [0.37],
    beach : [0.34],
    plains: [-1]
}

const ground_info = {
    none : "#3d332c",
    barrens : "palegoldenrod",
    
    plains : "lawngreen",
    forest : "#73523f",
    moss : "#447733",
    water : "#0f5e9c",
    shallow_water : "#2389da",
    beach : "#e1bf92"
}
const loot_tables = {
    sticks :{
        "stick" : {
            min: 1,
            max: 3
        },
        "long stick": {
            min:0,
            max:1
        }
    },
    bush : {
        "stick" : {
            min : 1,
            max : 2
        },
        "berries" : {
            min : 0,
            max : 2
        }
    }
}
const game_object_info = {
    none : {
        blocking:false
    },
    tree : {
        color:"brown",
        sign:"◉",
        blocking:true,
        tool : "axe"
    },
    tall_grass : {
        color:"#8dbf39",
        sign:"▥",
        blocking:false
    },
    stone : {
        color:"grey",
        sign:"▦",
        blocking:true,
        tool : "pickaxe"
    },
    chest : {
        color:"burlywood",
        sign:"▤",
        blocking:true
    },
    bush : {
        color : "#00A36C",
        sign:"◍",
        blocking:false
    },
    flower : {
        color : "purple",
        sign : "◻",
        blocking :false
    },
    sticks : {
        color : "brown",
        sign : "▤",
        blocking : false
    },
    plant : {
        color :"#52a84d",
        sign : "◇",
        blocking : false
    },
    rock : {
        color :"darkgrey",
        sign : "▣",
        blocking : false
    }
    //◎◉◍▢▣ ▤▥▦▧▨ ▩◧◨◩◪◫◰◱◲◳ ◻◼ ◬◭◮ ◸◹◺◿ ◤◥◣◢ ◐◑◒◓◔◕ ◴◵◶◷ ◡◠◟◞◝◜ ◈◇◆ ◁◀▶▷
    
}
const item_info = {
    berries :{
        type : "food",
        food : 2
    }
}
const crafting_recipes = {
    "grass rope" : {
        count : 1,
        input : {tall_grass : 3}
    }
}
const size = 10

//INITIAL SCRIPT

let seed = 1
let rng = mulberry32(seed)
let map_noise = [new Noise(seed),new Noise(seed+1)]

let render_radius = 11
let player = new Player(new Vector())
let map = {}
let turn = 0
let world_border = false

let day = true
let move_interval = 100 //time between moving
let can_move = true
let fly = false


start()
//FUNCTIONS

function start(){
    document.addEventListener('keydown', function(event) {
        let direction_number = 0
        switch (event.key) {
            case "ArrowUp" :
                direction_number = 1
                break
            case "ArrowRight" :
                direction_number = 2
                break
            case "ArrowDown" :
                direction_number = 3
                break
            case "ArrowLeft" :
                direction_number = 4
                break
                
        }

        if (can_move){
            if(event.ctrlKey){
                let vector = new Vector(player.pos.x,player.pos.y)
                destroyObject(directionVector(direction_number,vector))
                render()
            }
            if(direction_number > 0){
                movePlayer(direction_number)
                can_move = false
                setTimeout(() => {can_move=true},move_interval)
            }
        }
    });
    rng = mulberry32(seed)
    generateMap(seed)
    render()
}

//Graphic


//Random

function mulberry32(a) {
    return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}
function randomChances(num) {
    return rng() <= num
}


//World Generation

function generateMap(gen_seed) {
    map = {}
    map_noise = [new Noise(gen_seed),new Noise(gen_seed+1)]
}
function generateChunk(chunk_num){
    
    let chunk = []
    for(let i = 0; i < 16;i++){
        column = []
        for(let j = 0; j < 16;j++){
            column[j] = generateCell(new Vector(chunk_num.x*16+i,chunk_num.y*16 + j))
            //generateCell(new Vector(chunk.x*16+i,chunk.y*16 + j))
        }
        chunk[i] = column
    }
    map[chunk_num.to_string()] = chunk
}
function generateCell(vector) {
    let noise_values = []
    let noise_scale = 0.02
    map_noise.forEach(element => {
        noise_values.push(element.octave2(vector.x*noise_scale,vector.y*noise_scale,2,0.5,noise_scale))
    });

    biome = biomeDecider(noise_values[0])
    floor = biome
    let new_cell = new SquareCell()
    let game_object = "none"
    switch(biome){
        case "plains":
            if(randomChances(0.2)){
                game_object = "tall_grass"
            }
            else if (randomChances(0.04)){
                game_object = "stone"
            }
            else if (randomChances(0.04)){
                game_object = "flower"
            }
            else if (randomChances(0.02)){
                game_object = "tree"
            }
            break
        case "forest":
            if(randomChances(0.2)){
                game_object = "tree"
            }
            else if(randomChances(0.1)){
                game_object = "bush"
            }
            else if(randomChances(0.2)){
                game_object = "plant"
            }
            else if(randomChances(0.2)){
                game_object= "sticks"
            }
            if(randomChances(0.5)){
                floor = "moss"
            }
            break
        case "beach" :
            if (randomChances(0.2)){
                game_object = "rock"
            }
            break
    }
    new_cell = new SquareCell(floor,game_object)
    //map[vector.to_string()] = new_cell
    return new_cell
}
function biomeDecider(noise_value){
    for(let key in biomes){
        if (biomes[key] <= noise_value){
            return key
        }
    }
}


//Vectors

function directionVector(direction_num,vector){
    let new_vector = vector
    if(direction_num == 1) { new_vector.x -= 1; }
    if(direction_num == 2) { new_vector.y += 1; }
    if(direction_num == 3) { new_vector.x += 1; }
    if(direction_num == 4) { new_vector.y -= 1; }
    return new_vector
}
function mapCellFromVector(vector){
    let chunk_string = posToChunk(vector).to_string()
    
    if (chunk_string in map){
        local_pos_vector = toLocalPos(vector)
        return map[chunk_string][local_pos_vector.x][local_pos_vector.y]
    }
    else {
        return "none"
    }
    
}
function fixVectorBounds(vector) {
    new_vector = [vector.x,vector.y]
    for(let i = 0; i < 2; i++) {
        if(new_vector[i] < 0){new_vector[i] = (new_vector[i] % size) + size }
        if(new_vector[i] >= size) {new_vector[i] = new_vector[i] % size }
    }
    return new Vector(new_vector[0],new_vector[1])
}
function posToChunk(vector){
    return new Vector(Math.floor(vector.x / 16),Math.floor(vector.y / 16))
}
function toLocalPos(vector){
    new_vector = new Vector(vector.x % 16, vector.y % 16)
    if(vector.x < 0){
        new_vector.x = (new_vector.x + 16) % 16
    }
    if(vector.y < 0){
        new_vector.y = (new_vector.y + 16) % 16
    }
    return new_vector
}
//Inventory

function selectItem(item){
    if (item in item_info){
        player.feed(item)
    }
    else{
        player.selected_item = item
    }
    
    renderInventory()
}

//Crafting

function craftItem(recipe_name){
    if (checkRecipe(recipe_name,player.inventory)){
        for(let item in crafting_recipes[recipe_name].input){
            player.removeItem(item,crafting_recipes[recipe_name].input[item])
        }
        player.addItem(recipe_name,crafting_recipes[recipe_name].count)
        renderInventory()
    }
    
}
function checkRecipe(recipe_name){
    let loop_broken = false
    let input = crafting_recipes[recipe_name].input
    for (let item in input) {
        if (input[item] > player.inventory[item] || !(item in player.inventory) ){
            loop_broken = true
            break
        } 
    }
    return !loop_broken
}
function possibleCrafting(){
    let recipe_list = []
    for(let recipe in crafting_recipes){
        if (checkRecipe(recipe,player.inventory)){
            recipe_list.push(recipe)
        }
    }
    return recipe_list
}

//Loot table

function LootTable(loot_name){
    loot = loot_tables[loot_name]
    for(item in loot){
        player.addItem(item,getRandomInt(loot[item].min,loot[item].max)+1)
    }
}


//Action

function checkCollisions(vector){
   let cell = mapCellFromVector(vector)
    if(cell == "none"){
        return false
    }
    if (cell.isBlocking() && !fly) {
        return false
    }
    return true
    // True if you can move, False if you can't.
}
function movePlayer(direction_num) {

    let new_vector = new Vector(player.pos.x,player.pos.y)
    new_vector = directionVector(direction_num,new_vector)

    let collision = checkCollisions(new_vector)
    if(collision){
        player.pos = new_vector
        nextTurn()
    }
    
}
function teleport(vector) {
    let collision = checkCollisions(vector)
    if(collision){
        player.pos = vector
        nextTurn()
    }
}
function destroyObject(vector){
    let cell = mapCellFromVector(vector)
    if(cell != "none"){
        if(!cell.isEmpty() && (cell.game_object.info.tool in player.inventory || cell.game_object.info.tool == null )){
            if(cell.game_object.name in loot_tables){
                LootTable(cell.game_object.name)
            }
            else{
                player.addItem(cell.game_object.name)
            }
            cell.game_object.name = "none"
        }
    }
}
function placeObject(vector){
    let game_object = player.selected_item
    
    if(game_object in player.inventory && game_object in game_object_info){
        
        let cell = mapCellFromVector(vector)
        if(cell != "none"){
            if(cell.isEmpty() && !cell.isBlocking() ){
                player.removeItem(game_object)
                cell.game_object.name = game_object
                nextTurn()
            }
        }

    }
    
}

//NEXT TURN 
function nextTurn(){
    player.update()
    turn += 1
    render()
}

//Rendering
function render(){
    renderStats()
    renderInventory()
    renderGame()
}

function renderStats(){
    document.getElementById("health").innerHTML = `${Math.round(player.health)}/${player.max_health}`
    document.getElementById("hunger").innerHTML = `${Math.round(player.hunger)}/${player.max_hunger}`
    document.getElementById("pos").innerHTML = player.pos.to_string()
}
function renderInventory(){
    let text = ""
    for (let item in player.inventory){
        let color
        if(item == player.selected_item){
            color = "lime"
        }
        else{
            color = "black"
        }
        text += `<label style="color:${color}" onclick="selectItem('${item}')"><b>${item}</b> x ${player.inventory[item]}</label> <br>`
    }
    document.getElementById("inventory").innerHTML = text
    let crafting_list = possibleCrafting()
    text = ""
    for(let i in crafting_list){
        let recipe = crafting_list[i]
        text += `<label onclick="craftItem('${recipe}')"><b>${recipe}</b> x ${crafting_recipes[recipe].count}</label> <br>`
    }
    document.getElementById("crafting").innerHTML = text
}
function renderGame() {
    let text = ""
    let render_grid =  document.getElementById("game")
    for(let i = -render_radius; i <= render_radius; i++){
        let row = ""
        for(let j = -render_radius; j <= render_radius; j++){
            let render_pos = new Vector(i+player.pos.x,j+player.pos.y)
            let cell =  mapCellFromVector(render_pos)
            let render_info
            if (cell=="none"){
                if(world_border){
                    render_info = new RenderInfo("black","black","▩")
                }
                else{
                    generateChunk(posToChunk(render_pos))
                    render_info = mapCellFromVector(render_pos).getRenderInfo()
                }
            }
            else{
                render_info = cell.getRenderInfo()
            }
            
            if(render_pos.x == player.pos.x && render_pos.y == player.pos.y  ){
                render_info.color = "orange"
                render_info.sign = "◈"
            }
            let command = `placeObject(new Vector(${render_pos.x},${render_pos.y}))`
            let background
            if (day){
                background = `background-color:${render_info.background_color};`
            }
            else {background = ""}
            
            row += `<label onclick= "${command}" style="${background}color:${render_info.color}" >${render_info.sign}</label>`
        }
        text += row + "<br>"
    }
    document.getElementById("game").innerHTML = text
}





</script>