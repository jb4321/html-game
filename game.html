<!DOCTYPE html>
<style>
    body
    {
        background-color:rgb(126, 126, 126);
        font-family:'Courier New', Courier, monospace;
        
        line-height: 1;
    }
    
    header
    {
        font-weight: bold;
        font-size: 45px;
    }
    .main
    {
        display: flex;
        flex-flow: row wrap;
        justify-content: space-between;
    }
    .game
    {
        font-size: 30px;
        border: 3px black solid;
        overflow: hidden;
        background-color: black;
        
    }
    
    .inventory
    {
        background-color: lightgray;
        font-size: 25px;
        border: 3px black solid;
        flex-basis: 20%;
        
        
    }
    .other_column
    {
        background-color: lightgray;
        flex-basis: 20%;
        border: 3px black solid;
    }
    .selected_item{
        color:lime
    }

</style>
<html>
    <head>
        <meta charset="UTF-8">
        <title class="selected"> One File </title>
        <link rel="icon" href = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGRSURBVDhPjZM9LENRGIbv9bfaDbogQSIkUptBdJBIxMDCpkRCm0gMFpvBwKJNNNTGYjCRSspiI5EwiARTEztzyfW8PedcbtXPmzz9vnO+n957z3d8r0rBgdeFmYcxaNUeKsE9LPlTFRsqbEBhI2YTUpWNn7UFyzQqa1GnH4qbMKegYgW2oZ8kX8iHnI2loWBrzBOwyGIW4BlGKbrRfrXI68WcQAtkyUv5bHazuIV3GFAxex34azAO0hGsEnuwTS6hHnr0Ckm72LHF7fhXMAENlkntEWuzT7cLqkmqQQKkfWvXodm4EWlPMcnlJtQgZnzvztpha2vJxVxuTA0C438e6T/kcgM10JBIGiDpzNpacjGXW1KDovG9aWtX4NW4Eb2AYpLLLaqBvqiOcE5HxFd+xI/DIbyBhkd+nNgTOX34s6CavBukDGYR/hokFR+DBilDXto10FgWYAj0j3uQJ+Eaq7hGWfMyA5qLcxghXg6/PEm6TBugWf9Nkcv07eho1InRdR4Eja2kV7qAHIVfrrPnfQDq2nHJefonxAAAAABJRU5ErkJggg=="
        >
    </head>

    <body>
        <header style="text-align: center;"> 1File  </header> <br>
        <div class="main">
            <div id = "inventory"  class="inventory"></div>
            

            <div id="game" class="game">
                <p style="color: burlywood;">▢</p>
            </div>
            <div class="other_column" abc></div>
        </div>
    </body>
</html>

<script>

//CLASSES

//Noise
function Grad(x, y) {
    this.x = x; this.y = y;
    }
Grad.prototype.dot2 = function(x, y) {
    return this.x*x + this.y*y;
    }; 
class Noise{
        /*
        * A speed-improved perlin and simplex noise algorithms for 2D.
        *
        * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
        * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
        * Better rank ordering method by Stefan Gustavson in 2012.
        * Converted to Javascript by Joseph Gentle.
        *
        * Version 2012-03-09
        *
        * This code was placed in the public domain by its original author,
        * Stefan Gustavson. You may use it as you see fit, but
        * attribution is appreciated.
        *
        * 2022-04-04
        * Some modifications made by jb431
        */
        constructor(c_seed = 0)
        {
            this.seed_noise(c_seed)
        }
        // Skewing and unskewing factors for 2, 3, and 4 dimensions
        F2 = 0.5*(Math.sqrt(3)-1)
        G2 = (3-Math.sqrt(3))/6

        grad3 = [new Grad(1,1),new Grad(-1,1),new Grad(1,-1),new Grad(-1,-1)]
        p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
    
        // To remove the need for index wrapping, double the permutation table length
        perm = new Array(512);
        gradP = new Array(512);
    
        seed_noise(seed){
            if(seed > 0 && seed < 1) {
                // Scale the seed out
                seed *= 65536;
            }      
            seed = Math.floor(seed);
                if(seed < 256) {
                seed |= seed << 8;
            }
        
            for(var i = 0; i < 256; i++) {
                var v;
                if (i & 1) {
                    v = this.p[i] ^ (seed & 255);
                } else {
                    v = this.p[i] ^ ((seed>>8) & 255);
                }

                this.perm[i] = this.perm[i + 256] = v;
                this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 4];
            } 
        }
        // 2D Simplex Noise
        simplex2(xin,yin) {
            var n0, n1, n2; // Noise contributions from the three corners
            // Skew the input space to determine which simplex cell we're in
            var s = (xin+yin)*this.F2; // Hairy factor for 2D
            var i = Math.floor(xin+s);
            var j = Math.floor(yin+s);
            var t = (i+j)*this.G2;
            var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
            var y0 = yin-j+t;
            // For the 2D case, the simplex shape is an equilateral triangle.
            // Determine which simplex we are in.
            var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
            if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
                i1=1; j1=0;
            } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
                i1=0; j1=1;
            }
            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
            // c = (3-sqrt(3))/6
            var x1 = x0 - i1 + this.G2; // Offsets for middle corner in (x,y) unskewed coords
            var y1 = y0 - j1 + this.G2;
            var x2 = x0 - 1 + 2 * this.G2; // Offsets for last corner in (x,y) unskewed coords
            var y2 = y0 - 1 + 2 * this.G2;

            // Work out the hashed gradient indices of the three simplex corners
            i &= 255;
            j &= 255;
            var gi0 = this.gradP[i+this.perm[j]];
            var gi1 = this.gradP[i+i1+this.perm[j+j1]];
            var gi2 = this.gradP[i+1+this.perm[j+1]];
            // Calculate the contribution from the three corners
            var t0 = 0.5 - x0*x0-y0*y0;
            if(t0<0) {
                n0 = 0;
            } else {
                t0 *= t0;
                n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
            }
            var t1 = 0.5 - x1*x1-y1*y1;
            if(t1<0) {
                n1 = 0;
            } else {
                t1 *= t1;
                n1 = t1 * t1 * gi1.dot2(x1, y1);
            }
            var t2 = 0.5 - x2*x2-y2*y2;
            if(t2<0) {
                n2 = 0;
            } else {
                t2 *= t2;
                n2 = t2 * t2 * gi2.dot2(x2, y2);
            }
            
            // Add contributions from each corner to get the final noise value.
            // The result is scaled to return values in the interval [-1,1].

            return 70 * (n0 + n1 + n2);
        }
        octave2(x,y,num_iterations,persistence,scale,is_simplex = false){
            let max_amp = 0
            let amp = 1
            let freq = 1
            let noise_value = 0
            for(let i = 0; i < num_iterations; i++){
                if (is_simplex){
                    noise_value += this.simplex2(x * freq, y * freq) * amp
                }
                else{
                    noise_value += this.perlin2(x * freq, y * freq) * amp
                }
                
                max_amp += amp
                amp *= persistence
                freq *= 2
            }
            noise_value /= max_amp

            return noise_value
    }
        // ##### Perlin noise stuff
        fade(t) {
            return t*t*t*(t*(t*6-15)+10);
        }
        lerp(a, b, t) {
            return (1-t)*a + t*b;
        }
        // 2D Perlin Noise
        perlin2(x, y) {
            // Find unit grid cell containing point
            var X = Math.floor(x), Y = Math.floor(y);
            // Get relative xy coordinates of point within that cell
            x = x - X; y = y - Y;
            // Wrap the integer cells at 255 (smaller integer period can be introduced here)
            X = X & 255; Y = Y & 255;

            // Calculate noise contributions from each of the four corners
            var n00 = this.gradP[X+this.perm[Y]].dot2(x, y);
            var n01 = this.gradP[X+this.perm[Y+1]].dot2(x, y-1);
            var n10 = this.gradP[X+1+this.perm[Y]].dot2(x-1, y);
            var n11 = this.gradP[X+1+this.perm[Y+1]].dot2(x-1, y-1);

            // Compute the fade curve value for x
            var u = this.fade(x);

            // Interpolate the four results
            return this.lerp(
                this.lerp(n00, n10, u),
                this.lerp(n01, n11, u),
                this.fade(y));
        };
    }

//Game 
class Vector{
        constructor(x = 0,y = 0){
            this.x = x
            this.y = y
        }

        checkBound() {
            return this.x < 0 || this.x >= size || this.y < 0 || this.y >= size 
        }
    }
class SquareCell {
        constructor(floor_name = "default", object_name = "none") {
            this.floor = floor_name
            this.object_name = object_name
        }
        getRenderInfo(){
            if(this.isEmpty()){
                return new RenderInfo(floor_info[this.floor],floor_info[this.floor])
            }
            else {
                return new RenderInfo(floor_info[this.floor],object_info[this.object_name].color,object_info[this.object_name].sign)
            }
        }
        isBlocking(){
            return this.floor == "water" || object_info[this.object_name].blocking
        }
        isEmpty(){
            return this.object_name == "none"
        }
    }
class RenderInfo {
        constructor(background_color = "white",color = "black",sign = "▢") {
            this.background_color = background_color
            this.color = color
            this.sign = sign
        }
    }
class Player{
        constructor(pos){
            this.pos = pos
            this.inventory = {}
            this.selected_item = ""
        }
        addItem(item_name){
            if(item_name in this.inventory){
                this.inventory[item_name] += 1}
            else{
                this.inventory[item_name] = 1}
        }
        removeItem(item_name){
            this.inventory[item_name] -= 1
            if (this.inventory[item_name] <= 0){
                delete this.inventory[item_name]
            }
        }
    }

//CONSTANT DECLARATIONS
const world_border = true
const world_border_camera_effect = false
const biomes = {
    water : [0.05],
    forest: [-0.2],
    plains: [-1.5]
}

const floor_info = {
    default : "#C2B280",
    barrens : "palegoldenrod",
    
    plains : "lawngreen",
    forest : "forestgreen",
    water : "teal"
}
const object_info = {
    none : {blocking:false},
    tree : {color:"brown",sign:"◍",blocking:true},
    tall_grass : {color:"greenyellow",sign:"▥",blocking:false},
    stone : {color:"grey",sign:"▦",blocking:true},
    chest : {color:"burlywood",sign:"▤",blocking:true}
}
const item_info = {

}
const size = 100



//INITIAL SCRIPT
let seed = 2
let rng = mulberry32(seed)
let render_radius = 11
let player = new Player(new Vector(size/2,size/2))
let map = []

let day = false

start()

document.addEventListener('keydown', function(event) {
    let direction_number
    switch (event.key) {
        case "ArrowUp" :
        case "w":
            direction_number = 0
            break
        case "ArrowRight" :
        case "d":
            direction_number = 1
            break
        case "ArrowDown" :
        case "s":
            direction_number = 2
            break
        case "ArrowLeft" :
        case "a":
            direction_number = 3
            break
            
    }
    if(event.ctrlKey){
        let vector = new Vector(player.pos.x,player.pos.y)
        destroyObject(directionVector(direction_number,vector))
    }
    movePlayer(direction_number)
        

});

//FUNCTIONS
function start(){
    rng = mulberry32(seed)
    generateMap(seed)
    renderGame()
}

//Random
function mulberry32(a) {
    return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}
function randomChances(num) {
    return rng() <= num
}

//World Generation
function generateMap(gen_seed) {
    map = []
    let map_noise = [new Noise(gen_seed),new Noise(gen_seed+1)]
    
    noise_scale = 0.04
    for (let i = 0; i < size; i++) {
        row = []
        for (let j = 0; j < size; j++)
        {
            noise_values = []
            
            map_noise.forEach(element => {
                noise_values.push(element.octave2(i*noise_scale,j*noise_scale,2,0.5,noise_scale))
            });

            biome = biomeDecider(noise_values[0])
            new_cell = new SquareCell()
            switch(biome){
                case "plains":
                    new_cell = new SquareCell("plains")
                    if(randomChances(0.3)){
                        new_cell.object_name = "tall_grass"
                    }
                    else if (randomChances(0.1)){
                        new_cell.object_name = "stone"
                    }
                    break
                case "forest":
                    new_cell = new SquareCell("forest")
                    if(randomChances(0.2)){
                        new_cell.object_name = "tree"
                    }
                    break
                case "barrens":
                    new_cell = new SquareCell("barrens")
                    break
                case "water":
                    new_cell = new SquareCell("water")
            }
            
            
            row.push(new_cell)
        }
        map.push(row)
    }
    renderGame()
}
function biomeDecider(noise_value){
    for(let key in biomes){
        if (biomes[key] <= noise_value){
            return key
        }
    }
}

//Vectors
function directionVector(direction_num,vector){
    let new_vector = vector
    if(direction_num == 0) { new_vector.x -= 1; }
    if(direction_num == 1) { new_vector.y += 1; }
    if(direction_num == 2) { new_vector.x += 1; }
    if(direction_num == 3) { new_vector.y -= 1; }
    return new_vector
}
function mapCellFromVector(vector){
    return map[vector.x][vector.y]
}
function fixVectorBounds(vector) {
    new_vector = [vector.x,vector.y]
    for(let i = 0; i < 2; i++) {
        if(new_vector[i] < 0){new_vector[i] = (new_vector[i] % size) + size }
        if(new_vector[i] >= size) {new_vector[i] = new_vector[i] % size }
    }
    return new Vector(new_vector[0],new_vector[1])
}

//User Interface
function selectItem(item){
    player.selected_item = item
    renderInvetory()
}

//Action
function nextTurn(){
    renderGame()
    renderInvetory()
}
function moveEntity(vector,new_vector){
    if(world_border){
        if (new_vector.checkBound()){
            return vector
        }
    }
    else {
        new_vector = fixVectorBounds(new_vector)
    }
    if (mapCellFromVector(new_vector).isBlocking()) {
        return vector
    }
    return new_vector
}
function movePlayer(direction_num) {

    let new_vector = new Vector(player.pos.x,player.pos.y)
    new_vector = directionVector(direction_num,new_vector)

    player.pos = moveEntity(player.pos,new_vector)
    nextTurn()
}
function teleport(vector) {
    player.pos = moveEntity(player.pos,vector)
    nextTurn()
}
function destroyObject(vector){
    let cell = mapCellFromVector(vector)
    if(!cell.isEmpty()){
        player.addItem(cell.object_name)
        cell.object_name = "none"
    }

}
function placeObject(vector){
    object_name = player.selected_item
    if(object_name in player.inventory){
        
        let cell = mapCellFromVector(vector)
        if(cell.isEmpty() && !cell.isBlocking() ){
            player.removeItem(object_name)
            cell.object_name = object_name
        }
    }
    nextTurn()
}

//Rendering
function renderInvetory(){
    let text = ""
    for (item in player.inventory){
        let color
        if(item == player.selected_item){
            color = "lime"
        }
        else{
            color = "black"
        }
        text += `<label style="color:${color}" onclick="selectItem('${item}')"><b>${item}</b> x ${player.inventory[item]}</label> <br>`
    }
    document.getElementById("inventory").innerHTML = text
}
function renderGame() {
    
    let cor = [0,0]
    if(world_border_camera_effect) {
        if (player.pos.x - render_radius < 0) { cor[0] = -(player.pos.x - render_radius)}
        else if (player.pos.x + render_radius >= size) { cor[0] = size - (player.pos.x + render_radius) -1}

        if (player.pos.y - render_radius < 0) { cor[1] = -(player.pos.y - render_radius)}
        else if (player.pos.y + render_radius >= size) { cor[1] = size - (player.pos.y + render_radius) -1 }
    }
    
    let text = ""
    let render_grid =  document.getElementById("game")
    for(let i = -render_radius; i <= render_radius; i++){
        let row = ""
        for(let j = -render_radius; j <= render_radius; j++){
            let render_info
            
            render_pos = new Vector(cor[0]+i+player.pos.x,cor[1]+j+player.pos.y)
            
            if (render_pos.checkBound()) {
                if(world_border){
                    render_info = new RenderInfo("black","black","▩")
                }
                else{
                    render_info = mapCellFromVector(fixVectorBounds(render_pos)).getRenderInfo()
                }
            }
            else {
                render_info = mapCellFromVector(render_pos).getRenderInfo()
            }
            if(render_pos.x == player.pos.x && render_pos.y == player.pos.y  ){
                render_info.color = "orange"
                render_info.sign = "◉"
            }
            let command = `placeObject(new Vector(${render_pos.x},${render_pos.y}))`
            let background
            if (day){
                background = `background-color:${render_info.background_color};`
            }
            else {background = ""}
            row += `<label onclick= "${command}" style="${background}color:${render_info.color}" >${render_info.sign}</label>`
            
            
        }
        text += row + "<br>"
    }
    document.getElementById("game").innerHTML = text
}





</script>